#!/usr/bin/env python
# -*- coding: utf-8 -*-

import chainer
import chainer.links as L
import chainer.functions as F

import acne.methods

class {{ meta.name }}(chainer.Chain):

    def __init__(self):
        super({{ meta.name }}, self).__init__()

        # We add links outside the initializer
        # This allows more complex manipulations in __call__
        # and forward
        self.chain = []
        self.variables = {}

        {% for layer_name, layer_def in network.iteritems() %}
            chain += [
                        # Check if Function or Link and treat accordingly
                        {% if layer_def["type"].startswith('L')  %}
                            # It is a Link, phew
                            (
                                '{{ layer_name }}',
                                {{ layer_def["type"] }}(
                                                            {% for param, value in layer_def["params"].iteritems() %}
                                                                {{ param }}={{ value }}
                                                            {% endfor %}
                                                       )
                            )
                        {% else %}
                            # It is a Function, how annoying... they can have runtime
                            # parameters we need to handle correctly...somehow...acne...
                            (

                                TOODOODOOTOTODD
                                '{{ layer_name }}',
                                f = lambda self, x: {{ layer_def["type"] }}(
                                                                                {% for param, value in layer_def["params"].iteritems() %}
                                                                                        
                                                                                    {% if param in network["__states__"] %}
                                                                                        {{ param }}={{ value }}
                                                                                    {% else %}
                                                                                        {{ param }}=self.{{ value }}
                                                                                    {% endif %}
                                                                                {% endfor %}
                                                                           )
                            )
                        {% endif %}
                     ]

            # Sometimes we want to be able to extract several activatiosn at the same time,
            # so we need to be able to store intermediate results (only the data...)
            # simple...but...simply acne beautifuly
            {% if layer_def["is_variable"] %}
                self.variables[{{ layer_name }}] = None
            {% endif %}

        {% endfor %}

        # Generate Additional State Variables
        {% for state, value in states.iteritems() %}
            self.{{ state }} = value
        {% endfor %}

        # Create Dummy Entries for Later
        {% for loss_name in losses.keys() %}
            self.variables[{{ loss_name }}] = None
        {% endfor %}

        # Register Links with the Chainer library
        for link in self.chain:
            if link[0].startswith('L')::
                self.add_link(*link)

    def __call__(self,
                {% for var in data %}
                    {{ var }},
                {% endfor %}
                ):
        # Run the forward
        {% for output in network["__output__"] %} {{ output }}, {% endfor %} = \
            forward( {% for input in network["__input__"] %} {{ input }}, {% endfor %} )

        # Determine our losses *sniff*
        {% for loss_name, loss_def in losses.iteritems() %}
            {% if loss_name is "__loss__" %}{% continue %}{% endif %}
            # Calculate the loss as temporary variable
            {{ loss_name }} = {{ loss_def["type"] }}(
                                                        {% for param, value in loss_def["params"].iteritems() %}
                                                            {{ param }}={{ value }}
                                                        {% endfor %}
                                                    )
            # Store only the float value (should be smaller than the total loss)
            self.variables[{{ loss_name }}]
        {% endfor %}

        # Calculate cumulative loss
        self.loss = \ {% for loss_name, weight in losses["__loss__"] %}
                        {{ weight }} * {{ loss_name }} {% if not loop.last %} + \ {% endif %}
                    {% endfor %} 

        # Return output
        return self.loss


    def forward(self,
                {% for input in network["__input__"] %}
                    {{ input }},
                {% endfor %}
                target_layer = None):

        {% for layer_name, layer_def in network %}

        {% endfor %}


        for name, f in self.chain:
            x = f(x)

            # Store variable
            if name in self.variables:
                self.variables[name] = x.data

            if name == target_layer:
                break

        return {% for output in network["__output__"] %} {{ output }}, {% endfor %}